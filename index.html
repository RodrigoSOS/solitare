<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Paci√™ncia</title>

    <style>
        :root {
            --card-w: 80px;
            --card-h: 120px;
        }

        :root[data-theme="blue"] {}

        :root[data-theme="red"] {}

        html,
        body {
            height: 100%;
            overflow: hidden;
        }

        body {
            margin: 0;
            background: #0f5132;
            font-family: sans-serif;
            color: white;
            touch-action: none;

            display: flex;
            flex-direction: column;
        }

        #ui {
            display: flex;
            justify-content: space-between;
            padding: 10px;
        }

        button {
            padding: 6px 12px;
            font-size: 14px;
        }

        #game {
            padding: 10px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }


        .row {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }

        #game .row:last-child {
            flex: 1;
            align-items: flex-start;
        }

        .pile {
            width: var(--card-w);
            height: var(--card-h);
            border-radius: 8px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            position: relative;
            flex-shrink: 0;
        }

        .tableau {
            flex: 1;
            height: calc(100vh - 140px);
            /* levemente maior */
        }

        .card {
            width: var(--card-w);
            height: var(--card-h);
            border-radius: 8px;
            position: absolute;
            background-size: cover;
            background-position: center;
            user-select: none;
            touch-action: none;
            cursor: grab;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.25s ease;
        }

        .card.dragging {
            transition: none;
            z-index: 1000;
            cursor: grabbing;
            transform: scale(1.05);
        }

        .card.back1 {
            background-image: url("assets/cards/back.png");
        }

        .card.red {
            color: crimson;
        }

        .card.back {
            background: #1e3a8a;
            color: transparent;
        }

        .card.dragging1 {
            z-index: 1000;
            cursor: grabbing;
        }

        .drag-stack {
            position: fixed;
            pointer-events: none;
            z-index: 2000;
            transform: scale(1.03);
        }

        .card.selected {
            outline: 3px solid #4ade80;
            box-shadow: 0 0 12px rgba(74, 222, 128, 0.9);
        }

        .pile.selected-drop {
            border-color: #4ade80;
            box-shadow: 0 0 12px rgba(74, 222, 128, 0.9);
        }


        .pile.valid-drop {
            border-color: #4ade80;
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.7);
        }

        #waste .card {
            position: absolute;
        }

        #waste .card.waste-0 {
            left: 0px;
        }

        #waste .card.waste-1 {
            left: 12px;
        }

        #waste .card.waste-2 {
            left: 24px;
        }

        #newGameModal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            display: none;
        }

        #ui.hidden {
            display: none;
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .modal-content {
            position: relative;
            background: #064e3b;
            padding: 20px;
            border-radius: 12px;
            width: 300px;
        }

        .modal-close {
            position: absolute;
            top: 8px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
        }

        @media (max-width: 800px) {
            :root {
                --card-w: 64px;
                --card-h: 96px;
            }
        }

        @media (max-width: 500px) {
            :root {
                --card-w: 52px;
                --card-h: 78px;
            }

            .tableau .card {
                transform-origin: top center;
            }

            .row {
                gap: 8px;
            }
        }
    </style>
</head>

<body>
    <button id="menuToggle" onclick="toggleMenu()"
        style="position:fixed; bottom:10px; right:10px; z-index:4000;">‚ò∞</button>
    <button id="autoFinishBtn" onclick="autoFinishGame()" style="display:none">
        üèÅ Finalizar jogo
    </button>
    <button onclick="toggleFullscreen()" style="position:fixed; bottom:60px; right:10px; z-index:4000;">
        ‚õ∂
    </button>


    <div id="ui">
        <div>‚è±Ô∏è <span id="time">0</span>s</div>
        <button onclick="toggleAutoMove()">
            üñ±Ô∏è Auto-mover: <span id="autoMoveLabel">ON</span>
        </button>
        <div>
            <button onclick="undo()">‚Ü©</button>
            <button onclick="redo()">‚Ü™</button>
        </div>


        <button onclick="openNewGame()">Novo Jogo</button>
        <div>
            <button onclick="openModal('optionsModal')">‚öôÔ∏è</button>
            <button onclick="openModal('aboutModal')">‚ÑπÔ∏è</button>
        </div>


    </div>

    <div id="newGameModal">
        <div style="
    background: #064e3b;
    padding: 20px;
    border-radius: 12px;
    width: 280px;
  ">
            <button class="modal-close" onclick="closeModal('newGameModal')">‚úñ</button>

            <h3>Novo Jogo</h3>

            <label>
                Compra de cartas:
                <select id="drawSelect">
                    <option value="1">1 carta</option>
                    <option value="3" selected>3 cartas</option>
                </select>
            </label>

            <br><br>

            <label>
                Dicas:
                <select id="hintSelect">
                    <option value="none">Sem dicas</option>
                    <option value="valid" selected>Movimento v√°lido</option>
                    <option value="possible">Poss√≠veis movimentos</option>
                </select>
            </label>

            <br><br>

            <button onclick="startNewGame()">Come√ßar</button>
        </div>
    </div>
    <div id="optionsModal" class="modal">
        <div class="modal-content">
            <h3>Op√ß√µes</h3>

            <label>
                Auto-mover:
                <button onclick="toggleAutoMove()">
                    <span id="autoMoveLabelModal">ON</span>
                </button>
            </label>

            <br><br>

            <label>
                Tema:
                <select onchange="setTheme(this.value)">
                    <option value="blue">Azul</option>
                    <option value="red">Vermelho</option>
                </select>
            </label>

            <br><br>

            <label>
                Auto tela cheia:
                <button onclick="toggleAutoFullscreen()">
                    <span id="autoFullscreenLabel">ON</span>
                </button>
            </label>

            <br><br>

            <button onclick="closeModal('optionsModal')">Fechar</button>
        </div>
    </div>
    <div id="aboutModal" class="modal">
        <div class="modal-content">
            <h3>Sobre</h3>

            <p>
                Paci√™ncia (Klondike)<br>
                Feito em HTML + JS<br>
                üíö Projeto autoral
            </p>

            <button onclick="closeModal('aboutModal')">Fechar</button>
        </div>
    </div>
    <div id="winModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal('winModal')">‚úñ</button>

            <h2>üéâ Parab√©ns!</h2>
            <p>Voc√™ concluiu o jogo!</p>

            <p>‚è± Tempo: <span id="finalTime"></span>s</p>

            <button onclick="startNewGame()">Novo jogo</button>
        </div>
    </div>



    <div id="game">
        <!-- topo -->
        <div class="row">
            <div class="pile" id="stock"></div>
            <div class="pile" id="waste"></div>

            <div style="flex:1"></div>

            <div class="pile foundation" data-suit="hearts"></div>
            <div class="pile foundation" data-suit="diamonds"></div>
            <div class="pile foundation" data-suit="clubs"></div>
            <div class="pile foundation" data-suit="spades"></div>
        </div>

        <!-- tableau -->
        <div class="row">
            <div class="pile tableau" data-col="0"></div>
            <div class="pile tableau" data-col="1"></div>
            <div class="pile tableau" data-col="2"></div>
            <div class="pile tableau" data-col="3"></div>
            <div class="pile tableau" data-col="4"></div>
            <div class="pile tableau" data-col="5"></div>
            <div class="pile tableau" data-col="6"></div>
        </div>
    </div>

    <script>
        window.addEventListener("beforeunload", saveGame);
        window.addEventListener("contextmenu", e => e.preventDefault())
        const STACK_OFFSET = window.innerWidth < 500 ? 20 : 28;
        /* =========================
           PROPORTIONS
        ========================= */
        const CARD_RATIO = 120 / 80; // altura / largura
        const MIN_CARD_W = 42;
        const MAX_CARD_W = 80;
        const PILE_GAP = 12;

        /* =========================
           CONSTANTES
        ========================= */
        const suits = ["hearts", "diamonds", "clubs", "spades"];
        const values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];

        const HINT_MODE = {
            NONE: "none",
            VALID_ONLY: "valid",
            POSSIBLE: "possible"
        };

        let gameConfig = {
            drawCount: 1,
            hintMode: HINT_MODE.VALID_ONLY

        };

        gameConfig.doubleClickMove = true;
        gameConfig.autoFullscreen = true;

        /* =========================
           ESTADO DO JOGO
        ========================= */
        let stock = [];
        let waste = [];
        let foundations = { hearts: [], diamonds: [], clubs: [], spades: [] };
        let tableau = [[], [], [], [], [], [], []];

        let timer = 0;
        let timerInterval;

        let undoStack = [];
        let redoStack = [];
        let selection = null;
        let dragData = null;
        let isDragging = false;
        let dragStarted = false;

        const DRAG_THRESHOLD = 6; // px


        /* =========================
           BARALHO
        ========================= */
        let CARD_ID = 0;

        function createDeck() {
            const deck = [];
            for (let s of suits) {
                for (let v of values) {
                    deck.push({
                        id: CARD_ID++,
                        suit: s,
                        value: v,
                        faceUp: false
                    });
                }
            }
            return deck;
        }

        function shuffle(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function cardColor(card) {
            return (card.suit === "hearts" || card.suit === "diamonds") ? "red" : "black";
        }

        function checkWin() {
            const total =
                foundations.hearts.length +
                foundations.diamonds.length +
                foundations.clubs.length +
                foundations.spades.length;

            if (total === 52) {
                document.getElementById("finalTime").textContent = timer;
                openModal("winModal");
                clearInterval(timerInterval);
            }
        }
        /* =========================
           RENDER
        ========================= */
        function render() {
            document.querySelectorAll(".pile").forEach(p => p.innerHTML = "");

            stock.forEach(c => {
                const el = createCardElement(c);
                el.classList.add("back");
                document.getElementById("stock").appendChild(el);
            });

            const wastePile = document.getElementById("waste");

            // pega as √∫ltimas 3 cartas
            const visibleWaste = waste.slice(-3);

            visibleWaste.forEach((c, i) => {
                const el = createCardElement(c);

                // classe para deslocamento
                el.classList.add(`waste-${i}`);

                // s√≥ o topo pode ser arrastado
                if (i < visibleWaste.length - 1) {
                    el.style.pointerEvents = "none";
                }

                wastePile.appendChild(el);
            });


            for (let s of suits) {
                const pile = document.querySelector(`.foundation[data-suit="${s}"]`);
                foundations[s].forEach(c => {
                    pile.appendChild(createCardElement(c));
                });
            }

            tableau.forEach((col, i) => {
                const pile = document.querySelector(`.tableau[data-col="${i}"]`);
                col.forEach((c, idx) => {
                    const el = createCardElement(c);
                    el.style.top = (idx * STACK_OFFSET) + "px";
                    pile.appendChild(el);
                });
            });
            bindPileClick();
        }
        function bindPileClick() {
            document.querySelectorAll(".pile").forEach(pile => {
                pile.onpointerup = e => {
                    if (!selection) return;

                    if (canDropStackOn(selection.stack, selection.source, pile)) {
                        dragData = {
                            stack: selection.stack,
                            source: selection.source
                        };

                        attemptMove(pile);
                        clearSelection();
                        render();
                        saveGame();
                    } else {
                        clearSelection();
                    }
                };
            });
        }

        function createCardElement(card) {
            const el = document.createElement("div");
            el.className = "card";
            el.dataset.id = card.id;

            if (!card.faceUp) {
                el.classList.add("back");
            } else {
                el.style.backgroundImage = `url(${cardImage(card)})`;
            }

            if (card.faceUp) enableDrag(el, card);
            return el;
        }
        function cardImage(card) {
            const valueMap = {
                1: "A", 2: "02", 3: "03", 4: "04", 5: "05", 6: "06", 7: "07", 8: "08", 9: "09", 10: "10", 11: "J", 12: "Q", 13: "K"
            };
            const v = valueMap[card.value] || card.value;
            //return `assets/cards/${document.documentElement.dataset.theme}/${v}_${card.suit}.png`;
            return `cards/card_${card.suit}_${v}.webp`;
        }


        function label(card) {
            const map = { 1: "A", 11: "J", 12: "Q", 13: "K" };
            const suitMap = {
                hearts: "‚ô•", diamonds: "‚ô¶", clubs: "‚ô£", spades: "‚ô†"
            };
            return (map[card.value] || card.value) + suitMap[card.suit];
        }
        function setTheme(name) {
            document.documentElement.dataset.theme = name;
        }

        /* =========================
           DRAG & DROP
        ========================= */
        function cleanupDragStacks() {
            document.querySelectorAll(".drag-stack").forEach(el => el.remove());
        }

        function enableDrag(el, card) {
            let startX, startY;

            el.onpointerdown = e => {
                // üëâ N√ÉO cria ghost
                // üëâ N√ÉO esconde carta
                // üëâ N√ÉO mexe em sele√ß√£o

                startX = e.clientX;
                startY = e.clientY;

                dragStarted = false;
                isDragging = false;

                dragData = {
                    card,
                    stack: getStack(card),
                    source: findSource(card),
                    ghost: null,
                    originalEls: []
                };

                el.setPointerCapture(e.pointerId);
            };

            el.onpointermove = e => {
                if (!dragData) return;

                const dx = Math.abs(e.clientX - startX);
                const dy = Math.abs(e.clientY - startY);

                // üëâ s√≥ come√ßa drag se mover de verdade
                if (!dragStarted && (dx > DRAG_THRESHOLD || dy > DRAG_THRESHOLD)) {
                    startDrag(e, el);
                }

                if (!isDragging) return;

                dragData.ghost.style.left =
                    (e.clientX - dragData.offsetX) + "px";
                dragData.ghost.style.top =
                    (e.clientY - dragData.offsetY) + "px";

                highlightDropTargets();
            };

            el.onpointerup = e => {
                el.releasePointerCapture(e.pointerId);

                if (!isDragging) {
                    // Clique sem arrastar
                    e.stopPropagation(); // evita que o pointerup do pile sobrescreva
                    clearSelection();
                    selectCard(card);
                    return;
                }

                // Se foi drag ‚Üí drop
                handleDrop();
                cleanupDrag();
                render();
            };
        }
        function startDrag(e, el) {
            dragStarted = true;
            isDragging = true;

            cleanupDragStacks();

            // esconder cartas originais
            dragData.originalEls = [];
            document.querySelectorAll(".card").forEach(c => {
                const id = Number(c.dataset.id);
                if (dragData.stack.some(s => s.id === id)) {
                    c.style.visibility = "hidden";
                    dragData.originalEls.push(c);
                }
            });

            // criar ghost
            const ghost = document.createElement("div");
            ghost.className = "drag-stack";
            document.body.appendChild(ghost);

            dragData.stack.forEach((c, i) => {
                const cardEl = createCardElement(c);
                cardEl.style.position = "absolute";
                cardEl.style.top = (i * STACK_OFFSET) + "px";
                ghost.appendChild(cardEl);
            });

            dragData.ghost = ghost;

            const cardW = parseInt(getComputedStyle(document.documentElement)
                .getPropertyValue("--card-w"));
            const cardH = parseInt(getComputedStyle(document.documentElement)
                .getPropertyValue("--card-h"));

            dragData.offsetX = cardW / 2;
            dragData.offsetY = cardH / 2;

            ghost.style.left = (e.clientX - dragData.offsetX) + "px";
            ghost.style.top = (e.clientY - dragData.offsetY) + "px";
        }

        function cleanupDrag() {
            if (dragData?.ghost) {
                dragData.ghost.remove();
            }

            if (dragData?.originalEls) {
                dragData.originalEls.forEach(el => {
                    el.style.visibility = "visible";
                });
            }

            cleanupDragStacks();

            dragData = null;
            isDragging = false;
            dragStarted = false;

            document.querySelectorAll(".pile")
                .forEach(p => p.classList.remove("valid-drop"));
        }

        function canDropStackOn(stack, source, pile) {
            const temp = dragData;
            dragData = { stack, source };
            const ok = canDropOn(pile);
            dragData = temp;
            return ok;
        }

        /* =========================
           PILHAS ARRASTADAS
        ========================= */
        function getStack(card) {
            for (let col of tableau) {
                const idx = col.indexOf(card);
                if (idx !== -1) return col.slice(idx);
            }
            if (waste[waste.length - 1] === card) return [card];
            return [];
        }

        function findSource(card) {
            for (let i = 0; i < 7; i++) {
                const idx = tableau[i].indexOf(card);
                if (idx !== -1) return { type: "tableau", index: i, pos: idx };
            }
            return { type: "waste" };
        }
        function handleCardClick(card) {
            // mesma carta clicada novamente ‚Üí tenta auto-move
            if (selection && selection.card.id === card.id) {
                // cria dragData tempor√°rio com stack e source da sele√ß√£o
                dragData = {
                    stack: selection.stack,
                    source: selection.source
                };

                // tenta mover para foundation
                for (const pile of document.querySelectorAll(".foundation")) {
                    if (canDropOn(pile)) {
                        attemptMove(pile);
                        clearSelection();
                        render();
                        saveGame();
                        dragData = null;
                        return;
                    }
                }

                // tenta mover para tableau
                for (const pile of document.querySelectorAll(".tableau")) {
                    if (canDropOn(pile)) {
                        attemptMove(pile);
                        clearSelection();
                        render();
                        saveGame();
                        dragData = null;
                        return;
                    }
                }

                dragData = null; // n√£o encontrou movimento
                return;
            }

            // nova sele√ß√£o
            selectCard(card);
        }


        /* =========================
           DROP & VALIDA√á√ÉO
        ========================= */
        function canDropOn(pile) {
            if (!dragData || !dragData.stack || !dragData.stack.length) return false;

            if (!dragData) return false;

            if (pile.classList.contains("foundation")) {
                const suit = pile.dataset.suit;
                const card = dragData.stack[0];
                const f = foundations[suit];

                return (
                    dragData.stack.length === 1 &&
                    card.suit === suit &&
                    (
                        (f.length === 0 && card.value === 1) ||
                        (f.length && f[f.length - 1].value === card.value - 1)
                    )
                );
            }

            if (pile.classList.contains("tableau")) {
                const col = tableau[pile.dataset.col];
                const card = dragData.stack[0];

                if (!col.length) return card.value === 13;

                const top = col[col.length - 1];
                return (
                    cardColor(card) !== cardColor(top) &&
                    card.value === top.value - 1
                );
            }

            return false;
        }
        function rectsOverlap(a, b) {
            return !(
                a.right < b.left ||
                a.left > b.right ||
                a.bottom < b.top ||
                a.top > b.bottom
            );
        }
        function rectCenter(rect) {
            return {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        }
        function distance(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        function getActiveDragCardRect() {
            if (!dragData || !dragData.ghost) return null;

            // primeira carta visual da pilha (a que define a jogada)
            const firstCard = dragData.ghost.children[0];
            return firstCard.getBoundingClientRect();
        }

        function handleDrop() {
            if (!dragData || !dragData.ghost) return;

            const dragRect = getActiveDragCardRect();
            if (!dragRect) return;

            const dragCenter = rectCenter(dragRect);

            let bestPile = null;
            let bestDistance = Infinity;

            for (const pile of document.querySelectorAll(".pile")) {
                const pileRect = pile.getBoundingClientRect();

                // 1Ô∏è‚É£ precisa encostar DE VERDADE
                if (!rectsOverlap(dragRect, pileRect)) continue;

                // 2Ô∏è‚É£ precisa ser um movimento v√°lido
                if (!canDropOn(pile)) continue;

                // 3Ô∏è‚É£ escolher a mais pr√≥xima do centro da carta ativa
                const pileCenter = rectCenter(pileRect);
                const d = distance(dragCenter, pileCenter);

                if (d < bestDistance) {
                    bestDistance = d;
                    bestPile = pile;
                }
            }

            if (bestPile) {
                attemptMove(bestPile);
            }
            saveGame();
        }

        function attemptMove(pile) {
            if (!dragData) return;

            if (pile.classList.contains("foundation")) {
                moveToFoundation(pile.dataset.suit);
            }

            if (pile.classList.contains("tableau")) {
                moveToTableau(+pile.dataset.col);
            }
        }

        function moveToFoundation(suit) {
    const { removedStack, flipped } = removeFromSource();
    if (!removedStack.length) return;

    foundations[suit].push(...removedStack);

    recordMove({
        type: "move",
        from: dragData.source,
        to: { type: "foundation", suit },
        cards: removedStack,
        flipped
    });
}

function moveToTableau(colIndex) {
    const { removedStack, flipped } = removeFromSource();
    if (!removedStack.length) return;

    tableau[colIndex].push(...removedStack);

    recordMove({
        type: "move",
        from: dragData.source,
        to: { type: "tableau", index: colIndex },
        cards: removedStack,
        flipped
    });
}



        function selectCard(card) {
            clearSelection();

            const stack = getStack(card);
            if (!stack.length) return;

            selection = {
                card,
                stack,
                source: findSource(card)
            };

            // highlight cartas
            stack.forEach(c => {
                const pile = findPileElement(c);
                if (pile) pile.classList.add("selected");
            });

            highlightValidTargets();
        }

        function findPileElement(card) {
            return document.querySelector(`.card[data-id="${card.id}"]`);
        }

        function highlightValidTargets() {
            document.querySelectorAll(".pile").forEach(pile => {
                if (canDropStackOn(selection.stack, selection.source, pile)) {
                    pile.classList.add("selected-drop");
                }
            });
        }
        function attemptAutoMoveFromSelection() {
            if (!selection) return;

            dragData = {
                stack: selection.stack,
                source: selection.source
            };

            // Tenta foundation primeiro
            for (const pile of document.querySelectorAll(".foundation")) {
                if (canDropOn(pile)) {
                    attemptMove(pile);
                    clearSelection();
                    render();
                    saveGame();
                    dragData = null;
                    return;
                }
            }

            // Depois tableau
            for (const pile of document.querySelectorAll(".tableau")) {
                if (canDropOn(pile)) {
                    attemptMove(pile);
                    clearSelection();
                    render();
                    saveGame();
                    dragData = null;
                    return;
                }
            }

            dragData = null;
        }



        function removeFromSource() {
            const src = dragData.source;
            let flipped = null;
            let removedStack = [];

            if (src.type === "tableau") {
                const col = tableau[src.index];
                // remove o stack da posi√ß√£o exata
                removedStack = col.slice(src.pos);
                col.splice(src.pos); // agora remove do tableau

                // verifica se precisa virar a carta de baixo
                if (col.length && !col[col.length - 1].faceUp) {
                    col[col.length - 1].faceUp = true;
                    flipped = col[col.length - 1];
                }
            } else if (src.type === "waste") {
                removedStack = [waste.pop()];
            }

            return { removedStack, flipped };
        }



        /* =========================
           UNDO & REDO
        ========================= */
        function recordMove(move) {
            undoStack.push(move);
            redoStack.length = 0;
        }

        function undo() {
            const move = undoStack.pop();
            if (!move) return;

            redoStack.push(move);

            if (move.type === "draw") {
                move.cards.forEach(() => {
                    const c = waste.pop();
                    c.faceUp = false;
                    stock.push(c);
                });
            }

            if (move.type === "reset-stock") {
                waste = stock.map(c => ({ ...c, faceUp: true }));
                stock = [];
            }

            if (move.type === "move") {
                // remove do destino
                if (move.to.type === "tableau") {
                    tableau[move.to.index].splice(-move.cards.length);
                } else {
                    foundations[move.to.suit].pop();
                }

                // desfaz flip
                if (move.flipped) {
                    move.flipped.faceUp = false;
                }

                // volta para origem
                if (move.from.type === "tableau") {
                    tableau[move.from.index].push(...move.cards);
                } else {
                    waste.push(...move.cards);
                }
            }
            saveGame();
            render();
        }

        function redo() {
            const move = redoStack.pop();
            if (!move) return;

            undoStack.push(move);

            if (move.type === "draw") {
                move.cards.forEach(c => {
                    stock.pop();
                    c.faceUp = true;
                    waste.push(c);
                });
            }

            if (move.type === "reset-stock") {
                stock = waste.reverse().map(c => ({ ...c, faceUp: false }));
                waste = [];
            }

            if (move.type === "move") {
                // remove da origem
                if (move.from.type === "tableau") {
                    tableau[move.from.index].splice(-move.cards.length);
                } else {
                    waste.pop();
                }

                // aplica flip
                if (move.flipped) {
                    move.flipped.faceUp = true;
                }

                // aplica no destino
                if (move.to.type === "tableau") {
                    tableau[move.to.index].push(...move.cards);
                } else {
                    foundations[move.to.suit].push(move.cards[0]);
                }
            }
            saveGame();
            render();
        }
        /* =========================
           Save & Load
        ========================= */
        const SAVE_KEY = "solitaire-save-v1";

        function saveGame() {
            const state = {
                stock,
                waste,
                tableau,
                foundations,
                gameConfig,
                timer,
                undoStack,
                redoStack
            };

            localStorage.setItem(SAVE_KEY, JSON.stringify(state));
        }


        function preloadCardImages() {
            const images = [];
            const suits = ["hearts", "diamonds", "clubs", "spades"];
            const values = ["A", "02", "03", "04", "05", "06", "07", "08", "09", "10", "J", "Q", "K"];

            for (const suit of suits) {
                for (const value of values) {
                    const img = new Image();
                    img.src = `cards/card_${suit}_${value}.webp`;
                    images.push(img);
                }
            }

            // verso da carta
            const back = new Image();
            back.src = "assets/cards/back.png";
            images.push(back);

            return Promise.all(
                images.map(
                    img =>
                        new Promise(resolve => {
                            img.onload = resolve;
                            img.onerror = resolve;
                        })
                )
            );
        }

        function loadGame() {
            const raw = localStorage.getItem(SAVE_KEY);
            if (!raw) return false;

            try {
                const state = JSON.parse(raw);

                stock = state.stock;
                waste = state.waste;
                tableau = state.tableau;
                foundations = state.foundations;
                gameConfig = state.gameConfig;
                timer = state.timer || 0;
                document.getElementById("time").textContent = timer;


                undoStack = state.undoStack || [];
                redoStack = state.redoStack || [];

                clearInterval(timerInterval);
                timerInterval = setInterval(() => {
                    timer++;
                    document.getElementById("time").textContent = timer;
                }, 1000);


                render();
                return true;
            } catch (e) {
                console.warn("Save corrompido, iniciando novo jogo");
                localStorage.removeItem(SAVE_KEY);
                return false;
            }
        }

        /* =========================
           COMPRA 3 CARTAS
        ========================= */
        document.getElementById("stock").onclick = () => {
            const drawn = [];

            if (stock.length === 0) {
                stock = waste.reverse().map(c => ({ ...c, faceUp: false }));
                waste = [];

                recordMove({
                    type: "reset-stock"
                });
            } else {
                for (let i = 0; i < gameConfig.drawCount; i++) {
                    if (!stock.length) break;
                    const c = stock.pop();
                    c.faceUp = true;
                    waste.push(c);
                    drawn.push(c);
                }

                recordMove({
                    type: "draw",
                    cards: drawn
                });
            }

            render();
        };

        /* =========================
           AUTO MOVE    
        ========================= */

        function toggleAutoMove() {
            gameConfig.doubleClickMove = !gameConfig.doubleClickMove;

            document.getElementById("autoMoveLabel").textContent =
                gameConfig.doubleClickMove ? "ON" : "OFF";

            saveGame();
        }

        function handleAutoMove(card) {
            // s√≥ cartas viradas
            if (!card.faceUp) return;

            dragData = {
                card,
                stack: getStack(card),
                source: findSource(card),
                ghost: null
            };

            // s√≥ permite auto-move de uma carta
            if (dragData.stack.length !== 1) {
                dragData = null;
                return;
            }

            // 1Ô∏è‚É£ tenta foundation primeiro
            for (const pile of document.querySelectorAll(".foundation")) {
                if (canDropOn(pile)) {
                    attemptMove(pile);
                    dragData = null;
                    render();
                    saveGame();
                    return;
                }
            }

            // 2Ô∏è‚É£ tenta tableau
            for (const pile of document.querySelectorAll(".tableau")) {
                if (canDropOn(pile)) {
                    attemptMove(pile);
                    dragData = null;
                    render();
                    saveGame();
                    return;
                }
            }

            dragData = null;
        }



        /* =========================
           NOVO JOGO + TIMER
        ========================= */
        function openNewGame() {
            document.getElementById("newGameModal").style.display = "flex";
        }

        function startNewGame() {
            gameConfig.drawCount =
                parseInt(document.getElementById("drawSelect").value);

            gameConfig.hintMode =
                document.getElementById("hintSelect").value;

            document.getElementById("newGameModal").style.display = "none";
            updateCardSize();
            newGame();
        }

        function newGame() {
            localStorage.removeItem(SAVE_KEY);
            CARD_ID = 0;
            stock = createDeck();
            shuffle(stock);

            waste = [];
            foundations = { hearts: [], diamonds: [], clubs: [], spades: [] };
            tableau = [[], [], [], [], [], [], []];

            for (let i = 0; i < 7; i++) {
                for (let j = 0; j <= i; j++) {
                    const c = stock.pop();
                    if (j === i) c.faceUp = true;
                    tableau[i].push(c);
                }
            }

            clearInterval(timerInterval);
            timer = 0;
            document.getElementById("time").textContent = timer;
            timerInterval = setInterval(() => {
                timer++;
                document.getElementById("time").textContent = timer;
            }, 1000);

            render();
        }

        //newGame();
        preloadCardImages().then(() => {
            if (!loadGame()) {
                openNewGame();
            }
        });

        /* =========================
           Interface
        ========================= */
        function toggleMenu() {
            document.getElementById("ui").classList.toggle("hidden");
        }
        function openModal(id) {
            document.getElementById(id).style.display = "flex";
        }

        function closeModal(id) {
            document.getElementById(id).style.display = "none";
        }
        function updateCardSize() {
            const game = document.getElementById("game");

            const padding = 20; // padding lateral do game
            const availableWidth = window.innerWidth - padding;

            // topo: stock + waste + spacer + 4 foundations = 6 pilhas reais
            const pileCount = 6;

            // gap total entre pilhas
            const totalGaps = (pileCount - 1) * PILE_GAP;

            let cardW = Math.floor(
                (availableWidth - totalGaps) / pileCount
            );

            cardW = Math.max(MIN_CARD_W, Math.min(MAX_CARD_W, cardW));
            const cardH = Math.floor(cardW * CARD_RATIO);

            document.documentElement.style.setProperty("--card-w", cardW + "px");
            document.documentElement.style.setProperty("--card-h", cardH + "px");
        }

        window.addEventListener("resize", () => {
            updateCardSize();
            render();
        });

    </script>

    <script>
        if ("serviceWorker" in navigator) {
            navigator.serviceWorker.register("service-worker.js");
        }
        function toggleFullscreen() {
            const doc = document;
            const el = document.documentElement;

            if (
                !doc.fullscreenElement &&
                !doc.webkitFullscreenElement &&
                !doc.msFullscreenElement
            ) {
                if (el.requestFullscreen) {
                    el.requestFullscreen();
                } else if (el.webkitRequestFullscreen) {
                    el.webkitRequestFullscreen(); // Safari
                } else if (el.msRequestFullscreen) {
                    el.msRequestFullscreen(); // Edge antigo
                }
            } else {
                if (doc.exitFullscreen) {
                    doc.exitFullscreen();
                } else if (doc.webkitExitFullscreen) {
                    doc.webkitExitFullscreen();
                } else if (doc.msExitFullscreen) {
                    doc.msExitFullscreen();
                }
            }
        }
        function onFullscreenChange() {
            updateCardSize();
            updatePileHeight();
            render();
        }

        document.addEventListener("fullscreenchange", onFullscreenChange);
        document.addEventListener("webkitfullscreenchange", onFullscreenChange);
        let fullscreenTried = false;

        function isFullscreen() {
            return !!(
                document.fullscreenElement ||
                document.webkitFullscreenElement ||
                document.msFullscreenElement
            );
        }

        function tryAutoFullscreen() {
            if (!gameConfig.autoFullscreen) return;
            if (isFullscreen()) return;

            toggleFullscreen();
        }
        document.addEventListener("pointerdown", (e) => {
            // evita tentar fullscreen ao clicar em inputs/selects
            if (
                e.target.tagName === "SELECT" ||
                e.target.tagName === "OPTION" ||
                e.target.tagName === "INPUT"
            ) return;

            tryAutoFullscreen();
        });
        function toggleAutoFullscreen() {
            gameConfig.autoFullscreen = !gameConfig.autoFullscreen;

            document.getElementById("autoFullscreenLabel").textContent =
                gameConfig.autoFullscreen ? "ON" : "OFF";

            saveGame();
        }
        function clearSelection() {
            selection = null;

            document.querySelectorAll(".card.selected")
                .forEach(c => c.classList.remove("selected"));

            document.querySelectorAll(".pile.selected-drop")
                .forEach(p => p.classList.remove("selected-drop"));
        }

    </script>

</body>


</html>