<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paci√™ncia</title>

    <style>
        :root {
            --card-w: min(80px, calc((100vw - 40px) / 7 - 6px));
            --card-h: calc(var(--card-w) * 1.5);
        }

        :root[data-theme="blue"] {}

        :root[data-theme="red"] {}

        body {
            margin: 0;
            background: #0f5132;
            font-family: sans-serif;
            color: white;
            touch-action: none;
        }

        #ui {
            display: flex;
            justify-content: space-between;
            padding: 10px;
        }

        button {
            padding: 6px 12px;
            font-size: 14px;
        }

        #game {
            padding: 10px;
        }

        .row {
            display: flex;
            gap: clamp(4px, 1vw, 12px);
            margin-bottom: 16px;
        }


        .pile {
            width: var(--card-w);
            height: var(--card-h);
            min-width: var(--card-w);
            min-height: var(--card-h);
            border-radius: 8px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            position: relative;
            flex-shrink: 0;
        }

        .tableau {
            min-height: calc(var(--card-h) * 5);
        }

        .card {
            width: var(--card-w);
            height: var(--card-h);
            border-radius: 8px;
            position: absolute;
            background-size: cover;
            background-position: center;
            user-select: none;
            touch-action: none;
            cursor: grab;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.25s ease;
        }

        .card.dragging {
            transition: none;
            z-index: 1000;
            cursor: grabbing;
            transform: scale(1.05);
        }

        .card.back1 {
            background-image: url("assets/cards/back.png");
        }

        .card.red {
            color: crimson;
        }

        .card.back {
            background: #1e3a8a;
            color: transparent;
        }

        .card.dragging1 {
            z-index: 1000;
            cursor: grabbing;
        }

        .drag-stack {
            position: fixed;
            pointer-events: none;
            z-index: 2000;
            transform: scale(1.03);
        }


        .pile.valid-drop {
            border-color: #4ade80;
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.7);
        }

        #waste .card {
            position: absolute;
        }

        #waste .card.waste-0 {
            left: 0px;
        }

        #waste .card.waste-1 {
            left: 12px;
        }

        #waste .card.waste-2 {
            left: 24px;
        }

        #newGameModal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            display: none;
        }

        #ui.hidden {
            display: none;
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .modal-content {
            position: relative;
            background: #064e3b;
            padding: 20px;
            border-radius: 12px;
            width: 300px;
        }

        .modal-close {
            position: absolute;
            top: 8px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
        }

        @media (max-width: 500px) {
            .row {
                gap: 8px;
            }

        }
    </style>
</head>

<body>
    <button id="menuToggle" onclick="toggleMenu()"
        style="position:fixed; bottom:10px; right:10px; z-index:4000;">‚ò∞</button>
    <button id="autoFinishBtn" onclick="autoFinishGame()" style="display:none">
        üèÅ Finalizar jogo
    </button>


    <div id="ui">
        <div>‚è±Ô∏è <span id="time">0</span>s</div>
        <button onclick="toggleAutoMove()">
            üñ±Ô∏è Auto-mover: <span id="autoMoveLabel">ON</span>
        </button>
        <div>
            <button onclick="undo()">‚Ü©</button>
            <button onclick="redo()">‚Ü™</button>
        </div>


        <button onclick="openNewGame()">Novo Jogo</button>
        <div>
            <button onclick="openModal('optionsModal')">‚öôÔ∏è</button>
            <button onclick="openModal('aboutModal')">‚ÑπÔ∏è</button>
        </div>

    </div>

    <div id="newGameModal">
        <div style="
    background: #064e3b;
    padding: 20px;
    border-radius: 12px;
    width: 280px;
  ">
            <button class="modal-close" onclick="closeModal('newGameModal')">‚úñ</button>

            <h3>Novo Jogo</h3>

            <label>
                Compra de cartas:
                <select id="drawSelect">
                    <option value="1">1 carta</option>
                    <option value="3" selected>3 cartas</option>
                </select>
            </label>

            <br><br>

            <label>
                Dicas:
                <select id="hintSelect">
                    <option value="none">Sem dicas</option>
                    <option value="valid" selected>Movimento v√°lido</option>
                    <option value="possible">Poss√≠veis movimentos</option>
                </select>
            </label>

            <br><br>

            <button onclick="startNewGame()">Come√ßar</button>
        </div>
    </div>
    <div id="optionsModal" class="modal">
        <div class="modal-content">
            <h3>Op√ß√µes</h3>

            <label>
                Auto-mover:
                <button onclick="toggleAutoMove()">
                    <span id="autoMoveLabelModal">ON</span>
                </button>
            </label>

            <br><br>

            <label>
                Tema:
                <select onchange="setTheme(this.value)">
                    <option value="blue">Azul</option>
                    <option value="red">Vermelho</option>
                </select>
            </label>

            <br><br>

            <button onclick="closeModal('optionsModal')">Fechar</button>
        </div>
    </div>
    <div id="aboutModal" class="modal">
        <div class="modal-content">
            <h3>Sobre</h3>

            <p>
                Paci√™ncia (Klondike)<br>
                Feito em HTML + JS<br>
                üíö Projeto autoral
            </p>

            <button onclick="closeModal('aboutModal')">Fechar</button>
        </div>
    </div>
    <div id="winModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal('winModal')">‚úñ</button>

            <h2>üéâ Parab√©ns!</h2>
            <p>Voc√™ concluiu o jogo!</p>

            <p>‚è± Tempo: <span id="finalTime"></span>s</p>

            <button onclick="startNewGame()">Novo jogo</button>
        </div>
    </div>



    <div id="game">
        <!-- topo -->
        <div class="row">
            <div class="pile" id="stock"></div>
            <div class="pile" id="waste"></div>

            <div style="flex:1"></div>

            <div class="pile foundation" data-suit="hearts"></div>
            <div class="pile foundation" data-suit="diamonds"></div>
            <div class="pile foundation" data-suit="clubs"></div>
            <div class="pile foundation" data-suit="spades"></div>
        </div>

        <!-- tableau -->
        <div class="row">
            <div class="pile tableau" data-col="0"></div>
            <div class="pile tableau" data-col="1"></div>
            <div class="pile tableau" data-col="2"></div>
            <div class="pile tableau" data-col="3"></div>
            <div class="pile tableau" data-col="4"></div>
            <div class="pile tableau" data-col="5"></div>
            <div class="pile tableau" data-col="6"></div>
        </div>
    </div>

    <script>
        window.addEventListener("beforeunload", saveGame);
        window.addEventListener("contextmenu", e => e.preventDefault())
        /* =========================
           CONSTANTES
        ========================= */
        const suits = ["hearts", "diamonds", "clubs", "spades"];
        const values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];

        const HINT_MODE = {
            NONE: "none",
            VALID_ONLY: "valid",
            POSSIBLE: "possible"
        };

        let gameConfig = {
            drawCount: 3,
            hintMode: HINT_MODE.VALID_ONLY
        };

        gameConfig.doubleClickMove = true;


        /* =========================
           ESTADO DO JOGO
        ========================= */
        let stock = [];
        let waste = [];
        let foundations = { hearts: [], diamonds: [], clubs: [], spades: [] };
        let tableau = [[], [], [], [], [], [], []];

        let timer = 0;
        let timerInterval;

        let undoStack = [];
        let redoStack = [];


        /* =========================
           BARALHO
        ========================= */
        let CARD_ID = 0;

        function createDeck() {
            const deck = [];
            for (let s of suits) {
                for (let v of values) {
                    deck.push({
                        id: CARD_ID++,
                        suit: s,
                        value: v,
                        faceUp: false
                    });
                }
            }
            return deck;
        }

        function shuffle(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function cardColor(card) {
            return (card.suit === "hearts" || card.suit === "diamonds") ? "red" : "black";
        }

        function checkWin() {
            const total =
                foundations.hearts.length +
                foundations.diamonds.length +
                foundations.clubs.length +
                foundations.spades.length;

            if (total === 52) {
                document.getElementById("finalTime").textContent = timer;
                openModal("winModal");
                clearInterval(timerInterval);
            }
        }
        /* =========================
           RENDER
        ========================= */
        function render() {
            document.querySelectorAll(".pile").forEach(p => p.innerHTML = "");

            stock.forEach(c => {
                const el = createCardElement(c);
                el.classList.add("back");
                document.getElementById("stock").appendChild(el);
            });

            const wastePile = document.getElementById("waste");

            // pega as √∫ltimas 3 cartas
            const visibleWaste = waste.slice(-3);

            visibleWaste.forEach((c, i) => {
                const el = createCardElement(c);

                // classe para deslocamento
                el.classList.add(`waste-${i}`);

                // s√≥ o topo pode ser arrastado
                if (i < visibleWaste.length - 1) {
                    el.style.pointerEvents = "none";
                }

                wastePile.appendChild(el);
            });


            for (let s of suits) {
                const pile = document.querySelector(`.foundation[data-suit="${s}"]`);
                foundations[s].forEach(c => {
                    pile.appendChild(createCardElement(c));
                });
            }

            tableau.forEach((col, i) => {
                const pile = document.querySelector(`.tableau[data-col="${i}"]`);
                col.forEach((c, idx) => {
                    const el = createCardElement(c);
                    el.style.top = (idx * 28) + "px";
                    pile.appendChild(el);
                });
            });
        }

        function createCardElement(card) {
            const el = document.createElement("div");
            el.className = "card";
            el.dataset.id = card.id;

            if (!card.faceUp) {
                el.classList.add("back");
            } else {
                el.style.backgroundImage = `url(${cardImage(card)})`;
            }

            if (card.faceUp) enableDrag(el, card);
            return el;
        }
        function cardImage(card) {
            const valueMap = {
                1: "A", 2: "02", 3: "03", 4: "04", 5: "05", 6: "06", 7: "07", 8: "08", 9: "09", 10: "10", 11: "J", 12: "Q", 13: "K"
            };
            const v = valueMap[card.value] || card.value;
            //return `assets/cards/${document.documentElement.dataset.theme}/${v}_${card.suit}.png`;
            return `cards/card_${card.suit}_${v}.webp`;
        }


        function label(card) {
            const map = { 1: "A", 11: "J", 12: "Q", 13: "K" };
            const suitMap = {
                hearts: "‚ô•", diamonds: "‚ô¶", clubs: "‚ô£", spades: "‚ô†"
            };
            return (map[card.value] || card.value) + suitMap[card.suit];
        }
        function setTheme(name) {
            document.documentElement.dataset.theme = name;
        }

        /* =========================
           DRAG & DROP
        ========================= */
        let dragData = null;
        let lastClickTime = 0;
        let lastClickCardId = null;

        function cleanupDragStacks() {
            document.querySelectorAll(".drag-stack").forEach(el => el.remove());
        }

        function enableDrag(el, card) {
            let startX, startY, x = 0, y = 0;

            el.onpointerdown = e => {
                cleanupDragStacks();
                // monta dragData PRIMEIRO
                dragData = {
                    card,
                    stack: getStack(card),
                    source: findSource(card),
                    ghost: null
                };

                if (!dragData.stack.length) return;
                // esconder cartas originais da pilha
                dragData.originalEls = [];

                document.querySelectorAll(".card").forEach(el => {
                    const id = Number(el.dataset.id);
                    if (dragData.stack.some(c => c.id === id)) {
                        el.style.visibility = "hidden";
                        dragData.originalEls.push(el);
                    }
                });

                // cria container visual da pilha
                const ghost = document.createElement("div");
                ghost.className = "drag-stack";
                document.body.appendChild(ghost);

                // cria c√≥pias visuais das cartas da pilha
                dragData.stack.forEach((c, i) => {
                    const cardEl = createCardElement(c);
                    cardEl.style.position = "absolute";
                    cardEl.style.top = (i * 28) + "px";
                    cardEl.style.left = "0px";
                    ghost.appendChild(cardEl);
                });

                dragData.ghost = ghost;

                el.classList.add("dragging");

                const cardW = parseInt(getComputedStyle(document.documentElement)
                    .getPropertyValue("--card-w"));
                const cardH = parseInt(getComputedStyle(document.documentElement)
                    .getPropertyValue("--card-h"));

                dragData.offsetX = cardW / 2;
                dragData.offsetY = cardH / 2;

                ghost.style.left = (e.clientX - dragData.offsetX) + "px";
                ghost.style.top = (e.clientY - dragData.offsetY) + "px";


                el.setPointerCapture(e.pointerId);
            };


            el.onpointermove = e => {
                if (!dragData || !dragData.ghost) return;

                dragData.ghost.style.left =
                    (e.clientX - dragData.offsetX) + "px";
                dragData.ghost.style.top =
                    (e.clientY - dragData.offsetY) + "px";

                document.querySelectorAll(".pile").forEach(p => {
                    p.classList.remove("valid-drop");
                    if (canDropOn(p)) {
                        const dragRect = getActiveDragCardRect();
                        if (!dragRect) return;

                        const pileRect = p.getBoundingClientRect();
                        if (rectsOverlap(dragRect, pileRect)) {
                            p.classList.add("valid-drop");
                        }
                    }
                });

            };



            el.onpointerup = e => {
                el.releasePointerCapture(e.pointerId);
                el.classList.remove("dragging");

                const now = performance.now();

                // ‚úÖ DUPLO CLIQUE MANUAL
                if (
                    gameConfig.doubleClickMove &&
                    lastClickCardId === card.id &&
                    now - lastClickTime < 300 &&
                    dragData &&
                    dragData.stack.length === 1
                ) {
                    cleanupDragStacks();
                    dragData = null;

                    handleAutoMove(card);

                    lastClickTime = 0;
                    lastClickCardId = null;

                    document.querySelectorAll(".pile")
                        .forEach(p => p.classList.remove("valid-drop"));

                    return;
                }

                lastClickTime = now;
                lastClickCardId = card.id;

                // ‚úÖ DROP NORMAL
                handleDrop();

                cleanupDragStacks();

                if (dragData && dragData.originalEls) {
                    dragData.originalEls.forEach(el => {
                        el.style.visibility = "visible";
                    });
                }

                dragData = null;

                document.querySelectorAll(".pile")
                    .forEach(p => p.classList.remove("valid-drop"));

                render();
            };


        }

        /* =========================
           PILHAS ARRASTADAS
        ========================= */
        function getStack(card) {
            for (let col of tableau) {
                const idx = col.indexOf(card);
                if (idx !== -1) return col.slice(idx);
            }
            if (waste[waste.length - 1] === card) return [card];
            return [];
        }

        function findSource(card) {
            for (let i = 0; i < 7; i++) {
                const idx = tableau[i].indexOf(card);
                if (idx !== -1) return { type: "tableau", index: i, pos: idx };
            }
            return { type: "waste" };
        }

        /* =========================
           DROP & VALIDA√á√ÉO
        ========================= */
        function canDropOn(pile) {
            if (!dragData || !dragData.stack || !dragData.stack.length) return false;

            if (!dragData) return false;

            if (pile.classList.contains("foundation")) {
                const suit = pile.dataset.suit;
                const card = dragData.stack[0];
                const f = foundations[suit];

                return (
                    dragData.stack.length === 1 &&
                    card.suit === suit &&
                    (
                        (f.length === 0 && card.value === 1) ||
                        (f.length && f[f.length - 1].value === card.value - 1)
                    )
                );
            }

            if (pile.classList.contains("tableau")) {
                const col = tableau[pile.dataset.col];
                const card = dragData.stack[0];

                if (!col.length) return card.value === 13;

                const top = col[col.length - 1];
                return (
                    cardColor(card) !== cardColor(top) &&
                    card.value === top.value - 1
                );
            }

            return false;
        }
        function rectsOverlap(a, b) {
            return !(
                a.right < b.left ||
                a.left > b.right ||
                a.bottom < b.top ||
                a.top > b.bottom
            );
        }
        function rectCenter(rect) {
            return {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        }
        function distance(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        function getActiveDragCardRect() {
            if (!dragData || !dragData.ghost) return null;

            // primeira carta visual da pilha (a que define a jogada)
            const firstCard = dragData.ghost.children[0];
            return firstCard.getBoundingClientRect();
        }

        function handleDrop() {
            if (!dragData || !dragData.ghost) return;

            const dragRect = getActiveDragCardRect();
            if (!dragRect) return;

            const dragCenter = rectCenter(dragRect);

            let bestPile = null;
            let bestDistance = Infinity;

            for (const pile of document.querySelectorAll(".pile")) {
                const pileRect = pile.getBoundingClientRect();

                // 1Ô∏è‚É£ precisa encostar DE VERDADE
                if (!rectsOverlap(dragRect, pileRect)) continue;

                // 2Ô∏è‚É£ precisa ser um movimento v√°lido
                if (!canDropOn(pile)) continue;

                // 3Ô∏è‚É£ escolher a mais pr√≥xima do centro da carta ativa
                const pileCenter = rectCenter(pileRect);
                const d = distance(dragCenter, pileCenter);

                if (d < bestDistance) {
                    bestDistance = d;
                    bestPile = pile;
                }
            }

            if (bestPile) {
                attemptMove(bestPile);
            }
            saveGame();
        }

        function attemptMove(pile) {
            if (!dragData) return;

            if (pile.classList.contains("foundation")) {
                moveToFoundation(pile.dataset.suit);
            }

            if (pile.classList.contains("tableau")) {
                moveToTableau(+pile.dataset.col);
            }
        }

        function moveToFoundation(suit) {
            const stack = dragData.stack;
            const card = stack[0];
            const pile = foundations[suit];

            if (
                stack.length === 1 &&
                card.suit === suit &&
                (
                    (pile.length === 0 && card.value === 1) ||
                    (pile.length && pile[pile.length - 1].value === card.value - 1)
                )
            ) {
                const flipped = removeFromSource();
                pile.push(card);

                recordMove({
                    type: "move",
                    from: dragData.source,
                    to: { type: "foundation", suit },
                    cards: [card],
                    flipped
                });
            }
        }


        function moveToTableau(colIndex) {
            const col = tableau[colIndex];
            const card = dragData.stack[0];

            if (
                (col.length === 0 && card.value === 13) ||
                (col.length &&
                    cardColor(card) !== cardColor(col[col.length - 1]) &&
                    card.value === col[col.length - 1].value - 1)
            ) {
                const flipped = removeFromSource();
                col.push(...dragData.stack);

                recordMove({
                    type: "move",
                    from: dragData.source,
                    to: { type: "tableau", index: colIndex },
                    cards: dragData.stack,
                    flipped
                });
            }
        }


        function removeFromSource() {
            const src = dragData.source;
            let flipped = null;

            if (src.type === "tableau") {
                tableau[src.index].splice(src.pos);
                const col = tableau[src.index];

                if (col.length && !col[col.length - 1].faceUp) {
                    col[col.length - 1].faceUp = true;
                    flipped = col[col.length - 1];
                }
            }

            if (src.type === "waste") {
                waste.pop();
            }

            return flipped;
        }

        /* =========================
           UNDO & REDO
        ========================= */
        function recordMove(move) {
            undoStack.push(move);
            redoStack.length = 0;
        }

        function undo() {
            const move = undoStack.pop();
            if (!move) return;

            redoStack.push(move);

            if (move.type === "draw") {
                move.cards.forEach(() => {
                    const c = waste.pop();
                    c.faceUp = false;
                    stock.push(c);
                });
            }

            if (move.type === "reset-stock") {
                waste = stock.map(c => ({ ...c, faceUp: true }));
                stock = [];
            }

            if (move.type === "move") {
                // remove do destino
                if (move.to.type === "tableau") {
                    tableau[move.to.index].splice(-move.cards.length);
                } else {
                    foundations[move.to.suit].pop();
                }

                // desfaz flip
                if (move.flipped) {
                    move.flipped.faceUp = false;
                }

                // volta para origem
                if (move.from.type === "tableau") {
                    tableau[move.from.index].push(...move.cards);
                } else {
                    waste.push(...move.cards);
                }
            }
            saveGame();
            render();
        }

        function redo() {
            const move = redoStack.pop();
            if (!move) return;

            undoStack.push(move);

            if (move.type === "draw") {
                move.cards.forEach(c => {
                    stock.pop();
                    c.faceUp = true;
                    waste.push(c);
                });
            }

            if (move.type === "reset-stock") {
                stock = waste.reverse().map(c => ({ ...c, faceUp: false }));
                waste = [];
            }

            if (move.type === "move") {
                // remove da origem
                if (move.from.type === "tableau") {
                    tableau[move.from.index].splice(-move.cards.length);
                } else {
                    waste.pop();
                }

                // aplica flip
                if (move.flipped) {
                    move.flipped.faceUp = true;
                }

                // aplica no destino
                if (move.to.type === "tableau") {
                    tableau[move.to.index].push(...move.cards);
                } else {
                    foundations[move.to.suit].push(move.cards[0]);
                }
            }
            saveGame();
            render();
        }
        /* =========================
           Save & Load
        ========================= */
        const SAVE_KEY = "solitaire-save-v1";

        function saveGame() {
            const state = {
                stock,
                waste,
                tableau,
                foundations,
                gameConfig,
                timer,
                undoStack,
                redoStack
            };

            localStorage.setItem(SAVE_KEY, JSON.stringify(state));
        }


        function preloadCardImages() {
            const images = [];
            const suits = ["hearts", "diamonds", "clubs", "spades"];
            const values = ["A", "02", "03", "04", "05", "06", "07", "08", "09", "10", "J", "Q", "K"];

            for (const suit of suits) {
                for (const value of values) {
                    const img = new Image();
                    img.src = `cards/card_${suit}_${value}.webp`;
                    images.push(img);
                }
            }

            // verso da carta
            const back = new Image();
            back.src = "assets/cards/back.png";
            images.push(back);

            return Promise.all(
                images.map(
                    img =>
                        new Promise(resolve => {
                            img.onload = resolve;
                            img.onerror = resolve;
                        })
                )
            );
        }

        function loadGame() {
            const raw = localStorage.getItem(SAVE_KEY);
            if (!raw) return false;

            try {
                const state = JSON.parse(raw);

                stock = state.stock;
                waste = state.waste;
                tableau = state.tableau;
                foundations = state.foundations;
                gameConfig = state.gameConfig;
                timer = state.timer || 0;
                document.getElementById("time").textContent = timer;


                undoStack = state.undoStack || [];
                redoStack = state.redoStack || [];

                clearInterval(timerInterval);
                timerInterval = setInterval(() => {
                    timer++;
                    document.getElementById("time").textContent = timer;
                }, 1000);


                render();
                return true;
            } catch (e) {
                console.warn("Save corrompido, iniciando novo jogo");
                localStorage.removeItem(SAVE_KEY);
                return false;
            }
        }

        /* =========================
           COMPRA 3 CARTAS
        ========================= */
        document.getElementById("stock").onclick = () => {
            const drawn = [];

            if (stock.length === 0) {
                stock = waste.reverse().map(c => ({ ...c, faceUp: false }));
                waste = [];

                recordMove({
                    type: "reset-stock"
                });
            } else {
                for (let i = 0; i < gameConfig.drawCount; i++) {
                    if (!stock.length) break;
                    const c = stock.pop();
                    c.faceUp = true;
                    waste.push(c);
                    drawn.push(c);
                }

                recordMove({
                    type: "draw",
                    cards: drawn
                });
            }

            render();
        };

        /* =========================
           AUTO MOVE    
        ========================= */

        function toggleAutoMove() {
            gameConfig.doubleClickMove = !gameConfig.doubleClickMove;

            document.getElementById("autoMoveLabel").textContent =
                gameConfig.doubleClickMove ? "ON" : "OFF";

            saveGame();
        }

        function handleAutoMove(card) {
            // s√≥ cartas viradas
            if (!card.faceUp) return;

            dragData = {
                card,
                stack: getStack(card),
                source: findSource(card),
                ghost: null
            };

            // s√≥ permite auto-move de uma carta
            if (dragData.stack.length !== 1) {
                dragData = null;
                return;
            }

            // 1Ô∏è‚É£ tenta foundation primeiro
            for (const pile of document.querySelectorAll(".foundation")) {
                if (canDropOn(pile)) {
                    attemptMove(pile);
                    dragData = null;
                    render();
                    saveGame();
                    return;
                }
            }

            // 2Ô∏è‚É£ tenta tableau
            for (const pile of document.querySelectorAll(".tableau")) {
                if (canDropOn(pile)) {
                    attemptMove(pile);
                    dragData = null;
                    render();
                    saveGame();
                    return;
                }
            }

            dragData = null;
        }



        /* =========================
           NOVO JOGO + TIMER
        ========================= */
        function openNewGame() {
            document.getElementById("newGameModal").style.display = "flex";
        }

        function startNewGame() {
            gameConfig.drawCount =
                parseInt(document.getElementById("drawSelect").value);

            gameConfig.hintMode =
                document.getElementById("hintSelect").value;

            document.getElementById("newGameModal").style.display = "none";

            newGame();
        }

        function newGame() {
            localStorage.removeItem(SAVE_KEY);
            CARD_ID = 0;
            stock = createDeck();
            shuffle(stock);

            waste = [];
            foundations = { hearts: [], diamonds: [], clubs: [], spades: [] };
            tableau = [[], [], [], [], [], [], []];

            for (let i = 0; i < 7; i++) {
                for (let j = 0; j <= i; j++) {
                    const c = stock.pop();
                    if (j === i) c.faceUp = true;
                    tableau[i].push(c);
                }
            }

            clearInterval(timerInterval);
            timer = 0;
            document.getElementById("time").textContent = timer;
            timerInterval = setInterval(() => {
                timer++;
                document.getElementById("time").textContent = timer;
            }, 1000);

            render();
        }

        //newGame();
        preloadCardImages().then(() => {
            if (!loadGame()) {
                openNewGame();
            }
        });

        /* =========================
           UI
        ========================= */
        function toggleMenu() {
            document.getElementById("ui").classList.toggle("hidden");
        }
        function openModal(id) {
            document.getElementById(id).style.display = "flex";
        }

        function closeModal(id) {
            document.getElementById(id).style.display = "none";
        }


    </script>

    <script>
        if ("serviceWorker" in navigator) {
            navigator.serviceWorker.register("service-worker.js");
        }
    </script>
</body>

</html>